# 题目描述

**输入一个整型数组,数组中的一个或连续多个整数组成一个子数组.求所有子数组的和的最大值要求时间复杂度为 O(n)**

# 题目分析

- 整型数组
- 连续子数组最大和
- 时间复杂度为 O(n)

# 参数说明
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
```
# 题解及实现

1. 动态规划之新建数组 dp
   **显然这是道动态规划的题,从数组末尾往前数,一个数是否会在最终的连续最大和子数组里,取决于包含它的数组的最大和为多少,那怎么求得包含它的数组的最大和为多少呢?因为是相邻子数组,所以包含它的子数组只有两种情况 1.它本身组成的单个元素的子数组,2.包含它前面元素的和最大子数组,依此类推,显然第一位元素的最大和子数组只有他本身,故可以反向求解**

```js
var maxSubArray = function (nums) {
  if (!nums.length) return 0;
  let dp = [];
  dp[0] = 0;
  let i = 0;
  for (; i < nums.length; i++) {
    dp[i + 1] = dp[i] >= 0 ? dp[i] + nums[i] : nums[i];
  }
  //求得dp数组,即包含每一项的连续子数组最大和的值
  return Math.max(...dp.slice(1)); // 去除辅助项0
};
```

**时间复杂度:O(n),填充 dp 数组的时间和求数组中最大值的时间**

- 资源使用情况
  - 执行用时：88 ms, 在所有 JavaScript 提交中击败了 86.42%的用户
  - 内存消耗：44.7 MB, 在所有 JavaScript 提交中击败了 5.04%的用户
    **问题:为了获得更好的语义,使用了额外的 dp 数组,可以发现,原数组只会用到前一位的值,故剩余位可用于填充 dp 数组,而不必另外新增空间**

2. 动态规划之原地填充
   **在原数组上填充**

```js
var maxSubArray = function (nums) {
  if (!nums.length) return 0;
  let i = 0;
  for (; i < nums.length - 1; i++) {
    nums[i + 1] = nums[i] >= 0 ? nums[i] + nums[i + 1] : nums[i + 1];
  }
  return Math.max(...nums);
};
```
**时间复杂度:O(n)**

- 资源使用情况
  + 执行用时：84 ms, 在所有 JavaScript 提交中击败了93.12%的用户
  + 内存消耗：42.2 MB, 在所有 JavaScript 提交中击败了21.11%的用户
  **问题:原数组改变**

