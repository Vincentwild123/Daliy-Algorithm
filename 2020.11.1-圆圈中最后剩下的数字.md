# 题目描述

**0,1,...,n-1 这 n 个数字排成一个圆圈,从数字 0 开始,每次从这个圆圈里删除第 m 个数字.求出这个圆圈里剩下的最后一个数字.例如,0、1、2、3、4 这 5 个数字组成一个圆圈,从数字 0 开始每次删除第 3 个数字,则删除的前 4 个数字依次是 2、0、4、1,因此最后剩下的数字是 3**

# 题目分析

- 排成圈圈
- 每次删除第 m 个数字

# 参数说明

```js
/**
 * @param {number} n
 * @param {number} m
 * @return {number}
 */
```

# 题解及实现

**预备知识**
**1.为得到结果要删除 n-1 个元素**
**2.最后剩下的元素在每轮删除后都会留下**

**假设序列为 0,1,2,3,4,m 为 3,手工算的最后剩下的是 3**
**第一次删除 2,剩下 0,1,3,4 因为下一个是不从零开始数,而是从被删除元素 2 的下一位开始数,所以序列的排列等价于 3,4,0,1,数三次,得 0 被删除,剩下 3,4,1,同理等价于 1,3,4**

**很多朋友把数字和索引绑在一起把自己搞混了,我们用 A,B,C,D,E 来表示上述过程**
**1.对于 A,B,C,D,E 序列,m 为 3,最后剩下的是 D,在索引 3 的位置**
**删除第一个数:C,剩下 A,B,D,E,转换为 D,E,A,B 因为下次是从删除数得下一个开始数,此时我们掰手指算出来的最后剩下的 D 在索引为 0 的地方**
**删除第二个数:A,剩下 D,E,B,转换为 B,D,E,此时 D 在索引为 1 的地方,那么重点来了**
**先捋下,一开始,我们知道最后剩下的数字在每次删除后都是留下来的,只是他的索引值在变化,比如上列中我们推算出 D 最后会留下,每删除一个元素,他的索引值就会变,3->0->1,这个索引指的是转换后序列的索引**

**假设我们知道第 1 次删除后,D 的索引,那我们是否可以推出一次都没删除时 D 的索引,也就是剩下的数字**

**现在我们来看看,第一次删除发生后,D 的索引时怎么变化的**

**序列从 A,B,C,D,E 变为 A,B,D,E 转换为 D,E,A,B**

**那怎么从 D,E,A,B 变回原来的 A,B,C,D,E 呢?,显然,A,B,D,E 到 D,E,A,B 的转换操作只是为了更好数而让下一位归 0 而左移 m-1 个单位,此时只要将删除的 C 放到序列末尾后右移 m 个单位(因为加入了 C)即可变回原样**

1. 加入 C----> D,E,A,B,C
2. 右移 3 个单位 -----> A,B,C,D,E 超出长度的补到前面

**同理:元素的索引也经历了位移变化！！！！**

**删除后的 D 的索引是 0,经过位移和超出补全操作(0+m)%n,变为 3 成功得出 D**
**这里有两点需要注意**

1. 超出长度补全操作取得长度是 当前加上上一个删除元素后的长度
2. 原序列经过 n-1 次删除操作后,剩下 D,只有一个元素,索引为 0

### 1.递归

**按照递推关系,假设 f(n,m)表示的是最后剩下的元素每次删除变化后下标,则有 f(n,m)=(f(n-1,m)+m)n,且 n 为 1 时为 0**

```js
var lastRemaining = function (n, m) {
  if (n === 1) return 0;
  return (lastRemaining(n - 1, m) + m) % n;
};
```

**时间复杂度:O(n)**

- 资源使用情况
  - 执行用时：104 ms, 在所有 JavaScript 提交中击败了 42.42%的用户
  - 内存消耗：44.7 MB, 在所有 JavaScript 提交中击败了 31.39%的用户
    **问题:递归栈太多**

### 2.迭代

**由最后一次下标为 0 反向迭代**

```js
var lastRemaining = function (n, m) {
  let pos = 0;
  for (let i = 2; i <= n; i++) pos = (pos + m) % i;
  return pos;
};
```
**时间复杂度:O(n)**

- 资源使用情况
  + 执行用时：88 ms, 在所有 JavaScript 提交中击败了85.02%的用户
  + 内存消耗：37.6 MB, 在所有 JavaScript 提交中击败了39.34%的用户