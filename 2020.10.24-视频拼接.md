# 题目描述

**你将会获得一系列视频片段,这些片段来自于一项持续时长为  T  秒的体育赛事。这些片段可能有所重叠,也可能长度不一。视频片段  clips[i]  都用区间进行表示：开始于  clips[i][0]  并于  clips[i][1]  结束。我们甚至可以对这些片段自由地再剪辑,例如片段  [0, 7]  可以剪切成  [0, 1] + [1, 3] + [3, 7]  三部分。我们需要将这些片段进行再剪辑,并将剪辑后的内容拼接成覆盖整个运动过程的片段([0, T])。返回所需片段的最小数目,如果无法完成该任务,则返回  -1**

# 题目分析

- 覆盖整个运动
- 最小数目

# 参数说明

```js
/**
 * @param {number[][]} clips
 * @param {number} T
 * @return {number}
 */
```

# 题解及实现

### 1.动态规划

```js
1. 假设 dp[i]表示可以覆盖到 i 秒的最小片段数目
比如示例 1 中 dp[1]为 1,因为只有一个[0,2]片段可以覆盖
2. 本题中要求 dp[T],能覆盖到 T 秒的片段表示为 clip[0]<=T<=clip[1]
比如示例 1 中的[8,10],注意,可能会有多个满足的 clip
3. 在可能存在多个满足的 clip 下,dp[T]就会等于 Min(dp[clip[0]])+1 clip[0]为多个满足覆盖 T 的 clip 的左端点,
比如第 2 步中的[8,10]中的 8
4. 由题可知, 0<=T<=100,且为整数,故设 dp[0] = 0;开始从头递推
```

```js
function videoStitching(clips, T) {
  let dp = new Array(T + 1).fill(101); //大于100表示不可能覆盖到
  dp[0] = 0; //初始值
  for (let i = 1; i <= T; i++) {
    for (clip of clips) {
      //两轮迭代寻找能覆盖到i的clip
      if (clip[0] < i && clip[1] >= i) {
        dp[i] = Math.min(dp[i], dp[clip[0]] + 1); //寻找最小数目
      }
    }
  }
  return dp[T] === 101 ? -1 : dp[T];
}
```

**时间复杂度:O(Tn)**

- 资源使用情况
  - 执行用时：84 ms, 在所有 JavaScript 提交中击败了 72.73%的用户
  - 内存消耗：39.1 MB, 在所有 JavaScript 提交中击败了 6.06%的用户

### 2.贪心算法

**有一个基本的事实,每次当片段左端点相同时,取右端点最远的片段,按这样的规则取覆盖整个视频片段就是最小的片段数,例如有片段(0,2),(0,3),(2,3),(4,5),(3,5)若想取最小片段数覆盖 T=5,在(0,2),(0,3)两个片段中就取(0,3),后面再取(3,5)就完成了,_这就是贪心的思想,在一定条件下能选的片段中选右端点最远的_,那这个一定条件是什么呢?很明显,在例子中,第一次选择(0,3)后,即使(4,5)片段也能扩展边界且为最远边界,但其左边并没有与(0,3)接壤,显然是不可能覆盖到(3,4)这个时间段的,所以可以得到 2 条贪心规范**

- 贪心规范 0:在下列规范约束下,选择右边界最远者
- 贪心规范 1:下一步所选片段必须和前一片段接壤
  **那怎么知道哪个片段右边界最远呢?最简单的就是遍历了,遍历全部片段,记录左端点相同,右端点最远的,记录到达的位置就好了,因为一个值就是一个片段,记录一个值就是选中了这个片段,其他左端点和它一样,右端点没他远的就被淘汰了**
- 贪心规范 2:记录每个左端点能到达最远的位置

**简单说一下步骤**

1. 从 0 时刻开始的片段中,选择右端点最远的片段作为第一个片段 1
2. 遍历接下来所有片段,选择左端点与片段 1 右端点接壤的片段,取其中右端点最远的片段
3. 重复步骤 2,直到选择的片段的右端点大于等于 T

**举个例子**

```js
- 输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
- 输出：3
```

1. 第一次遍历选择 0 时刻开始的片段 (0,2)
2. 再遍历,选择左端点小于 2 的片段中,右端点最远的 (1,9)
3. 重复 2,此时更新左端点条件为左端点小于 9 (8，10)
4. 最远可到达 10,共选择 3 次

**不想做多次遍历就排序,左端点排好序再遍历一次就行**

```js
function videoStitching(clips, T) {
  let a = new Array(T + 1).fill(-1);
  for (var clip of clips) a[clip[0]] = Math.max(a[clip[0]] || 0, clip[1]);
  //储存左端点为每个时刻的片段的最远到达值
  if (a[0] === -1) return -1; //0时刻不可到达
  let sum = 0; //计数,选择了几次片段
  let max = 0; //最远的值
  let end = 0; //最端点条件边界
  let j = 0;
  while (j < T) {
    if (j > end) return -1; //出现断层
    //遍历满足左端点约束条件的片段,选择最远到达点并更新max
    for (; j <= end; ++j) {
      max = Math.max(max, a[j]);
    }
    //每选择完一个片段就更新左端点约束值
    end = max;
    sum++;
    if (max >= T) return sum; //满足条件
  }
  return -1;
}
```

**时间复杂度:O(n),填充数组时遍历 O(n),选择时遍历 O(n)**

- 资源使用情况
  - 执行用时：80 ms, 在所有 JavaScript 提交中击败了 82.86%的用户
  - 内存消耗：37.9 MB, 在所有 JavaScript 提交中击败了 5.72%的用户

**同思路排序版,时间换空间**

```js
function videoStitching(clips, T) {
  //按左端点起始大小排序,保证遍历一遍即可
  clips.sort((a, b) => {
    return a[0] - b[0];
  });
  let sum = 0;
  let max = 0;
  let end = 0;
  let j = 0;
  while (j < clips.length) {
    if (clips[j][0] > end) return -1;
    while (clips[j] && clips[j][0] <= end) {
      max = Math.max(max, clips[j][1]);
      ++j;
    }
    end = max;
    sum++;
    if (max >= T) return sum;
  }
  return -1;
}
```
- 资源使用情况
 - 执行用时：92 ms, 在所有 JavaScript 提交中击败了 26%的用户
  - 内存消耗：37.2 MB, 在所有 JavaScript 提交中击败了 43.72%的用户